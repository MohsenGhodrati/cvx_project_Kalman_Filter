\documentclass{scribe-cgenomics}
\usepackage{float}
\usepackage{subfig}

\begin{document}

\جلسه
{دکتر مجتبی تفاق، ترم دوم سال تحصیلی ۱۴۰۱}
{پروژه درس بهینه‌سازی در علوم داده}
{محسن قدرتی، محمد صالح بهرامی}


\section{مقدمه}
در این گزارش قصد داریم الگوریتم فیلتر کالمن 
\cite{mainkalman}
را برای بهبود (فیلتر) برآوردهای یک بردار وضعیت، معرفی کنیم و با ارایه تعدادی مدل ساده از دینامیک تغییرات قیمت رمز ارز بیت‌کوین، قدرت فیلتر کالمن در پیش‌بینی آینده را محک بزنیم. در انتها نیز، تعمیم‌هایی از فیلتر کالمن به دینامیک‌های غیر خطی و مساله‌های با چندین مدل موازی را بیان خواهیم کرد. مشوق ما در مطالعه فیلتر کالمن، فهم بهتر تعدادی از مقالات بهینه‌سازی  در این خصوص از جمله
\cite{boyd1}،
\cite{boyd2}
و
\cite{boyd3}
بود.

مطالعات ما در این گزارش، مربوط به نحوه تغییرات میانگین قیمت معاملاتی بیت‌کوین در بازه دو ماهه از دسامبر ۲۰۱۹ الی ژوییه ۲۰۲۰ است که از صرافی بایننس تهیه شده و مربوط به کندل‌های ۵ دقیقه‌ای است. به نظر می‌رسد نتایج نهایی کمابیش در سایر بازارها و یا سایر پارامترهای بازار و سایر بازه‌های زمانی نیز قابل پیاده‌سازی باشد.

\section{تعاریف اولیه}
\subsection{مدل‌های اتوریگرسیو}
مدل‌های اتورگرسیو
\cite{autoreg}، مدل‌هایی هستند که فرض می‌کنند مقدار یک سری زمانی به تعدادی ثابت از مقادیر قبلی به شکل خطی وابسته است و تفاضل این دو مقدار از یکدیگر یک نویز غیر قابل اندازه‌گیری خواهد بود. به عبارت دیگر، اگر
$x_t$
یک سری زمانی باشد، مدل زیر یک مدل اتورگرسیو است:

\begin{center}
$
x_t = \sum_{i = 1}^{m}x_{t-i} + \epsilon_t
$
\end{center}


\subsection{فیلتر}
فرض کنید به دنبال اندازه‌گیری وزن یک شمش طلا هستیم و یک ترازو داریم که در اندازه‌گیری خود مقداری خطا دارد و هر بار یک وزن خاص بر می‌گرداند
\cite{kalman}.

\begin{figure}
\includegraphics[width=3in]{ex1_MeasurementsVsTrueVal.png}
\centering
\end{figure}

با فرض آنکه مانگین خطای ترازوی مورد نظر ما صفر است (نویز سفید داریم)، یک راه موثر برای تخمین وزن واقعی طلا، آن است که چندین بار شمش را وزن کنیم و میانگین وزن‌های یافته شده را برگردانیم. اما برای بروزرسانی میانگین مذکور، وقتی
$n$
بار آزمایش انجام شده است و مشاهداتی داشته‌ایم، نیازی به ذخیره‌سازی همگی نتایج نیست.
کافی است به نکته زیر توجه کنیم:

\begin{center}
$
\bar{x}_n = \dfrac{x_1 + \dots + x_n}{n} = 
\dfrac{(n-1)\bar{x}_{n-1} + x_n}{n} = \bar{x}_{n-1} + \dfrac{1}{n}(x_n - \bar{x}_{n-1})
$
\end{center}

\begin{figure}
\includegraphics[width=4in]{exm1.png}
\centering
\end{figure}

یعنی کافیست در گام
$n$ام،
میانگین را به اندازه ضریبی ($\dfrac{1}{n}$) در جهت تفاضل مشاهده جدیدمان از این میانگین موجود، تغییر دهیم. به این فرآیند، فیلتر کردن می‌گویند. در واقع با داشتن یک مشاهده و یک تقریب تا لحظه
$n$ام،
فیلتر کردن یعنی آن که به نحوی این دو مقدار را با یکدیگر ترکیب کنیم که بهترین تقریب جدید ساخته شود. در شکل 
\ref{example1}
 شمایی از روند تکراری فیلتر کردن یک سری زمانی را مشاده می‌کنیم:

\begin{figure}\label{example1}
\includegraphics[width=4.5in]{ex1_estimationAlgorithm.png}
\centering
\end{figure}




\section{معرفی مساله داده‌کاوی}
\subsection{صورت مساله و داده‌ها}
داده‌های این مساله، شامل اطلاعات کندلی ۵ دقیقه‌ای دو ماه از بازار بیت‌کوین در صرافی بایننس است
\cite{binance}. این اطلاعات شامل میانگین قیمت معاملاتی بیت‌کوین در هر کندل نیز می‌شود. برای دسترسی به کلیه کدهای نوشته شده و تصاویر با وضوح اصلی، به
\cite{git}
مراجعه کنید. قصد داریم با مدل‌های مختلف فیلتر کالمن، و اطلاعات قیمتی و حجمی تا به یک لحظه خاص، تغییرات قیمتی در ۵ دقیقه بعدی را پیش‌بینی کنیم.

سطرهای اولیه داده‌ها به صورت زیر است:

\begin{figure}
\includegraphics[width=6in]{Screenshot 2022-08-02 02.01.24.png}
\centering
\end{figure}

\begin{مشاهده}

همانطور که در شکل 
\ref{prices}
 مشاهده می‌شود، قیمت بیت‌کوین در حوالی روز‌های سال نو میلادی، در یک روند صعودی قرار داشته است
 \cite{traidingview}.

\begin{figure}\label{prices}
\includegraphics[width=6in]{prices.png}
\centering
\end{figure}
\end{مشاهده}


\subsection{تخمین حافظه موثر}
حافظه یک مدل اتورگرسیو عبارت است از تعداد مشاهداتی از سری زمانی که برای مدل‌سازی دینامیک مشاهده جدید لازم دارد. در شکل
\ref{corr_with_future_m}، 
ضریب همبستگی تغییرات قیمتی بیت‌کوین در یک دقیقه آینده با تغییرات قیمتی از
$t$
دقیقه قبل تا این لحظه رسم شده است. همانطور که از شکل
\ref{corr_with_future_m}
 مشخص است، برای آنکه حداقل همبستگی
$\dfrac{1}{4}$
داشته باشیم، لازم است حافظه را به
$m=14$
محدود کنیم. یعنی رابطه جدی بین زمان‌های دورتر از ۱۴ دقیقه قبل با لحظه فعلی وجود ندارد.

\begin{figure}\label{corr_with_future_m}
\includegraphics[width=6in]{Correlation with Future.png}
\centering
\end{figure}

در ادامه، پیاده‌سازی‌های خود را به دو عدد
$m=15$
و
$m=60$
محدود می‌کنیم.





\subsection{تخمین سایز مناسب برای یادگیری دینامیک مساله}
دینامیک مساله در مدل اتورگرسیو، شامل تعدادی ضریب اسکالر و یک عرض از مبدا ثابت است. در واقع برای یافتن این ضرایب، نیاز به حل یک معادله رگسیون خطی داریم. اما اینکه تا چند نمونه برای یافتن ضرایبی با دقت بالا (pvalue ناچیز) لازم است، خود به
validation
اختیاج دارد. در شکل 
\ref{best_k}،
 واریانس نویز مدل‌های خطی بدون کنترل، به ازای تعداد نمونه استفاده شده در یادگیری ضرایب دینامیک مدل رسم شده است. مدل آبی به ازای حافظه
$m=15$
و مدل نارنجی به ازای حافظه
$m=60$
تولید شده است. همانطور که از شکل پیداست، هنگامی که حافظه افزایش می‌یابد، واریانس نویز سیستم خطی نیز افزایش می‌یابد. یعنی حافظه خیلی بزرگ معادل است با عدم قطعیت بیشتر در پیش‌بینی تغییرات قیمت بیت‌کوین. هم‌چنین توجه می‌کنیم که هر دو مدل تقریبا به ازای همه انتخاب‌های
$k$
از مدلی که تغییرات قیمتی بیت‌کوین را برابر با تغییرات قیمتی در لحظه قبل می‌داند، بهتر هستند. اما از طرفی هیچ‌کدام از مدلی که تغییرات قیمتی را صفر پیش‌بینی می‌کند بهتر نیستند. دلایل اینکه از صفر پیش‌بینی کردن بهتر نیستیم، زیاد است و به تحلیل اقتصادی در کنار تحلیل داده‌ها نیاز دارد. اما تعدادی از عمده‌ترین دلایل چنین پیش‌بینی‌ناپذیریی عبارتند از اینکه اول از همه، دینامیک تغییرات قیمت در بازارهای کارایی مانند بیت‌کوین، به شدت غیرخطی و غیریکنواخت است. دوم اینکه در بسیاری از زمان‌ها، به دلیل عدم وجود اتفاق نظر در بین اهالی بازار، رفتار قیمت تصادفی یا بسیار سبه تصادفیست. پس مدلی که بخواهد در همه زمان‌ها تغییرات قیمت را پیش‌بینی کند، ناچار است بسیاری از نمونه‌هایش را از متغیرهایی بگیرد که کاملا نرمال و تصادفی متقارن هستند. در نتیچه بهتر از توزیعی که نمونه‌هایش داراست، نمی‌تواند پیش‌بینی انجام دهد. یعنی همان پیش‌بینی
$\hat{X}_n = 0$.

\begin{figure}\label{best_k}
\includegraphics[width=4in]{best_k.png}
\centering
\end{figure}

در این گزارش، هدف پیش‌بینی موثر بازار بیت‌کوین نیست و صرفا به دنبال پیاده سازی فیلتر کالمن هستیم. لذا با وجود موارد بالا، به روند خود ادامه می‌دهیم.






\subsection{تهیه تعدادی ویژگی (کنترل دینامیک)}
همانطور که در ادامه خواهیم دید، افزودن ویژگی‌های مختلف بر حسب قیمت و حجم معاملات، کمک قابل توجهی به رگرسیون نمی‌کند. نقش این ویژگی‌ها بیشتر از آنکه در رگرسیون باشد، در جداسازی موقعیت‌های خاص بازار است. مثلا هنگامی که حجم معاملات به طور ناگهانی چند برابر می‌شود، یا تعداد معاملات افزایش چشمگیر می‌یابد. نقش اصلی ویژگی‌ها در تعیین خاص بودن یک موقعیت بازار است و نه در پیش‌بینی قیمت. اما این یک تجربه و نظر شخصی است و از ویژگی‌های زیر در کنار داده‌های سری زمانی استفاده خواهیم کرد.

\begin{enumerate}
\item{
\lr{taker buy volume ratio}:
نسبت حجمی اجرا کنندگان معاملات بازار که موقعیت خرید داشته‌اند به آن‌هایی که موقعیت فروش داشته‌اند.
}
\item{
\lr{volume (1e3)}:
حجم در مقیاس کیلو
}
\item{
\lr{volume change}:
تغییرات حجم به صورت درصدی (صد درصد همان یک فرض می‌شود)
}
\item{
\lr{trades number (1e3)}:
تعداد معاملات انجام شده
}
\item{
\lr{trades number change}:
تغییرات تعداد معاملات انجام شده
}
\item{
\lr{taker buy average spread (1e-3)}:
فاصله میانگین قیمت خرید اجراکنندگان سفارش که بیت‌کوین خریده‌اند با میانگین کل
}
\item{
\lr{taker sell average spread (1e-3)}:
فاصله میانگین قیمت فروش اجراکنندگان سفارش که بیت‌کوین فروخته‌اند با میانگین کل
}

\end{enumerate}

\begin{مشاهده}
همانطور که در شکل
\ref{corr_plot}
 مشاهده می‌کنید، از میان ویژگی‌هایی که انتخاب کرده‌ایم، نسبت حجم بیت‌کوینی که خریداران سفارش را برداشته‌اند به حجم بیت‌کوینی که فروشندگان سفارش را برداشته‌اند، همبستگی قابل توجهی تا چند دقیقه با بازدهی قیمت دارد. هم‌چنین مشاهده می‌کنیم که همبستگی حجم و تغییرات حجم با بازدهی بلند مدت به مرور مثبت می‌شود.

\begin{figure}\label{corr_plot}
\includegraphics[width=2.5in]{correlation plot.png}
\centering
\end{figure}
\end{مشاهده}

\begin{مشاهده}
مشاهده بعدی مربوط به محدود کردن وضعیت‌های مورد مطالعه بازار به آن‌هایی است که نغییرات حجم مثبت قابل توجه داریم. در این راستا، شکل
\ref{taker_buy_filtered_corrs}
 همبستگی ویژگی مورد توجه در نمودار بالا را با بازده آتی به ازای محدود‌سازی‌های مختلف تغییرات حجم نشان می‌دهد. شکل خود گویاست که با افزایش محدودیت تغییرات حجم، همبستگی ویژگی مورد نظر با بازدهی قیمت افزایش می‌یابد.


\begin{figure}\label{taker_buy_filtered_corrs}
\includegraphics[width=3in]{taker_buy_filtered_corrs.png}
\centering
\end{figure}
\end{مشاهده}


% --------------------------------------------- %
\section{فیلتر کالمن}
% --------------------------------------------- %
% >>
\subsection{تعریف}
فیلتر کالمن الگوریتمی است که با ترکیب تقریب‌های خام اولیه و مشاهده و اندازه‌گیری‌هایی از سیستم (که فرض می‌شود هم مشاهده ما از سیستم و هم تقریب‌های خام هر دو دارای خطا هستند)، یک تقریب بهبود یافته به دست می‌دهد. فرض کنید 
$x_t$
 متغیری باشد  که نحوه تغییرات آن در طول زمان به طور "حدودی" به وسیله سیستم دینامیکی خطی
\begin{center}
$
x_t=Fx_{t-1}+Gu_{t-1}+w{t-1}                                                                                                                      
$
\end{center}

قابل توصیف باشد.که در آن
$w_{t-1}$
یک متغیر تصادفی است که نویز یا خطای مدل نام دارد.
هم‌چنین فرض کنید
$Q_{t-1}$
ماتریس کواریانس
$w_{t-1}$
باشد به گونه‌ای که
$w_{t-1}\sim \mathcal{N}(\bold{0}, Q_{t-1})$.
از طرفی فرض کنید برای هر 
$t$
به جای دسترسی مستقیم به
$x_t$
به یک نسخه نویزی از آن مثل
$z_t$
 دسترسی داریم که :
\begin{center}
$
z_t = x_t + v_t
$
\end{center}

و در اینجا
$v_t$
یک متغیر تصادفی با توزیع 
$v_{t}\sim \mathcal{N}(\bold{0}, R_{t})$ 
است.
تا به این جا ما دو تقریب از مقدار 
$x_t$
بدست آورده ایم که عبارتند از:

\begin{itemize}
\item{
تقریب با استفاده از مدل دینامیک سیستم
($Fx_{t-1}+Gu_{t-1}$)
}
\item{
تقریب با استفاده از مشاهده و اندازه گیری
($z_t$)
}
\end{itemize}

الگوریتم کالمن به طریق زیر یک تقریب بهبود یافته نسبت به هردوی تقریب‌های قبلی بدست می‌دهد.



% >>
\subsection{الگوریتم}

\begin{figure}
\includegraphics[width=6in]{algorithm.png}
\centering
\end{figure}

در این تصویر 
\cite{intech}
علامت منفی روی تقریب‌ها به معنی این است که این تقریب اولیه است و علامت مثبت یعنی تقریب بعد از انجام الگوریتم کالمن بهبود یافته است.
آنچه که در تصویر بالا در قسمت محاسبات مربوط به prediction  مطرح شده است در واقع تخمین اولیه و میزان عدم قطعیتی است که ما از تخمین خود داریم. این تقریب از فرض ما بدست می آید که نحوه تغییرات
$x_t$
 به وسیله سیستم دینامیک خطی اشاره شده توضیح داده می‌شود.

الگوریتم کالمن به طور شهودی، عدم قطعیت هر یک از دو برآورد (مشاهده و تخمین اولیه) خود را در نظر می‌گیرد و بر مبنای آن، یک ترکیب محدب از این دو برآورد ارایه می‌دهد.

در این خصوص، توجه به شکل 
\ref{kalman_gain}
 خالی از لطف نیست
 \cite{kalman}. در این شکل دو موقعیت فرضی تصویر شده است که در یکی، عدم قطعیت مقدار اندازه‌گیری شده بالاست ولی عدم قطعیت تخمینی مدل کم است. لذا تخمین تصحیح شده توسط فیلتر کالمن به مقدار تخمینی مدل وزن بیشتری می‌دهد. در عکس دوم وضعیت برعکس است.

\begin{figure}
\subfloat[تمایل به تخمین مدل]{\includegraphics[width = 3in]{gain_1.png}} 
\subfloat[تمایل به مقدار اندازه‌گیری شده]{\includegraphics[width = 3in]{gain_2.png}} 
 
\label{kalman_gain}
\centering
\end{figure}

به طور خلاصه، فرآیندی که توسط الگوریتم کالمن به صورت تکراری و متناوب طی می‌شود، در شماتیک زیر آمده است:

\begin{figure}
\includegraphics[width=5in]{process2.png}
\centering
\end{figure}


% >>
\subsection{عدم قطعیت}
در این قسمت سعی داریم فرمول محاسبه عدم قطعیت را ثابت کنیم:
\begin{figure}
\includegraphics[width=5in]{pn_deduction.png}
\centering
\end{figure}

برای این کار، به اثبات گام به گام 
\ref{uncertaity_proof}
 توجه می‌کنیم
\cite{kalman}:

\begin{figure}
\subfloat[]{\includegraphics[width = 7in]{pn_deduction_1.png}}\\
\subfloat[]{\includegraphics[width = 7in]{pn_deduction_2.png}} 
\label{uncertaity_proof}
\centering
\end{figure}


% >>
\subsection{پیاده‌سازی}

\subsubsection{مدل ۱: دینامیک خطی بدون کنترل}
فرض می‌کنیم دینامیک تغییرات قیمت به شکل زیر باشد:
\begin{equation}\label{linear_model_without_control}
\tilde{r}_n = f_{0, n}\tilde{r}_{n-1} + \sum_{i=1}^{m-1}f_{i, n} r_{i,n-1} + f_{m, n} + w_n,
\qquad
w_n \sim \mathcal{N}(0,\ \sigma_n^{2}) \..
\end{equation}
به عبارت دیگر، فرض می‌کنیم اگر تغییرات قیمت از
$i = 2,\ \dots,\ m-1$
کندل گذشته تا کندل گذشته را بدانیم و تغییرات قیمت از کندل گذشته تا کندل فعلی را نیز بدانیم، بازدهی پیش رو ترکیبی خطی از این مقادیر به علاوه یک نویز با توزیع نرمال است.
در این صورت برای بردار
$\bold{x^{(n)}}$
فرم معادل زیر را خواهیم داشت:

\begin{equation}
\bold{x^{(n)}} = F_n\bold{x^{(n-1)}} + \bold{w^{(n)}},
\end{equation}

که در آن
\begin{center}
$
\bold{x^{(n)}} := 
\begin{bmatrix}
\tilde{r}_n \\
r_{1, n} \\
\vdots \\
r_{m-1, n} \\
1
\end{bmatrix},
\quad 
F_n := 
\begin{bmatrix}
f_{0, n} & f_{1, n} & \dots & f_{m, n} \\
1 + \tilde{r}_{n-1} & 0 & \ddots & 0 \\
0 & 1 + \tilde{r}_{n-1} & 0 & \vdots \\
0 & \ddots &  & 0 \\
\vdots & 0  & 1 + \tilde{r}_{n-1} & 0 \\
0 & \dots & 0 & 1
\end{bmatrix},
\quad
\bold{w^{(n)}} := 
\begin{bmatrix}
w_n \\
-{\tilde{r}_{n-1}}^2 \\
\tilde{r}_{n-1} \\
\vdots \\
\tilde{r}_{n-1} \\
0
\end{bmatrix}\..
$
\end{center}
با توجه به این که در هر لحظه
$n$، 
بردار
$\bold{x^{(n-1)}}$
معلوم است و کواریانس بردار
$\bold{w^{(n)}}$
تنها در درایه
$1,1$
ناصفر و برابر با
$\sigma_n^2$
است، به دنبال مقادیری از
$f_{0, n},\ \dots,\ f_{m-1, n}$
می‌گردیم که
$\sigma_n^2$
را کمینه کند. (در واقع خطای مدل را در حد امکان کاهش دهد.) هم‌چنین توجه می‌کنیم که اضافه کردن عدد
$1$
به انتهای بردار
$\bold{x^{(n)}}$
باعث می‌شود بتوان عرض از مبدا مدل
\ref{linear_model_without_control}
را به
$f_{m,n}$
منتقل کرد و لذا فرض صفر بودن میانگین نویز
$w_n$
برقرار است. اکنون سعی می‌کنیم با بازنویسی معادله بالا، فرم مجموع مربعاتی برای یافتن بهترین
$f_{i,n}$ها
ارایه کنیم.

اگر قرار دهیم
$\theta_n = (f_{0,n},\ \dots,\ f_{m, n})^T$،
به دنبال حل مساله بهینه‌سازی زیر هستیم:
\begin{center}
$minimize_{(\theta_n)}\quad |\tilde{r}_n - \langle\theta_n,\ \bold{x^{(n-1)}}\rangle |^2$
\end{center}
اما با توجه به اینکه مساله بالا احتمالا بی‌نهایت جواب دارد و این موضوع باعث تغییرات سریع دینامیک مدل در هر لحظه می‌شود که خلاف طبیعت مدل است، و مهم‌تر آنکه انتظار داریم دینامیک مدل در طول یک پنجره کوتاه مدت
($k$تایی)
پایدار باشد (یعنی
$\theta_{n}\simeq \theta_{n-1} \simeq \dots \simeq \theta_{n-(k-1)}$) و بتوانیم از اطلاعات این پنجره برای تقریب یک دینامیک کم‌نوسان بهره ببریم، مساله بهینه‌سازی فوق را به مساله زیر تعمیم می‌دهیم:
\begin{center}
$minimize_{(\theta_n)} \quad |\tilde{r}_{n-(k-1)} - \langle\theta_{n},\ \bold{x^{(n-1-(k-1))}}\rangle |^2 + \dots + |\tilde{r}_n - \langle\theta_n,\ \bold{x^{(n-1)}}\rangle |^2$
\end{center}
که با در نظر گرفتن ماتریس
$X^{(n)}$
به صورت
\begin{center}
$
X^{(n)} = 
\begin{bmatrix}
\bold{x^{(n-(k-1))}}^T \\
\vdots \\
\bold{x^{(n)}}^T \\
\end{bmatrix}
\quad
\rightarrow
\quad
X^{(n)} :=
\begin{bmatrix}
\bold{b^{(n)}_0} & \dots & \bold{b^{(n)}_m}
\end{bmatrix}
$
\end{center}
به فرم زیر قابل بیان است:
\begin{equation}\label{linear_model_without_control_optimization}
for\ given\ n:\quad minimize_{(\theta_n)}\ ||X^{(n-1)}\theta_n - \bold{b^{(n)}_0}||_2^2
\end{equation}
توجه به این نکته ضروری است که از بردار
$X^{(n)}_0$،
درایه اول مربوط به بازدهی آینده است و در درسترس نیست. لذا به جای حل مساله فوق برای
$n$
آن را برای
$n-1$
حل می‌کنیم.

در ادامه به بررسی نتایج حاصل از حل مساله بهینه‌سازی
\ref{linear_model_without_control_optimization}
به کمک روش کمترین مجموع مربعات و پیاده‌سازی فیلتر کالمن بر روی مدل
\ref{linear_model_without_control}
می‌پردازیم.

\begin{مشاهده}
مطابق با نمودار زیر می‌توان فرض نرمال بودن نویز در اندازه‌گیری و مدل را تا حدودی تایید کرد. هم‌چنین توجه می‌کنیم که میانگین توزیع نویز، با دقت ۷ رقم اعشار صفر خواهد بود.

\begin{figure}
\includegraphics[width=0.5\textwidth]{Errors Histogram [Linear Model without Control].png}
\centering
\end{figure}
\end{مشاهده}

\begin{مشاهده}
همان‌طور که اشاره کردیم، فرض می‌کنیم دینامیک مدل دچار تغییرات سریع نمی‌شود. این نکته در نمودار زیر به صورت طیف‌های پیوسته قابل مشاهده است. هم‌چنین در نمودار زیر این نکته قابل توجه وجود دارد که ضرایب بزرگ‌تر و تاثیرگذارتر در مدل خطی پیشنهاد شده، به لحظات نزدیک‌تر به لحظه حال مرتبط می‌شوند. این نیز مشاهده‌ای است که انتظارش را داشتیم.

\begin{figure}
\includegraphics[width=1.1\textwidth]{Heatmap [Linear Model without Control].png}
\centering
\end{figure}
\end{مشاهده}

\begin{نتیجه}
در شکل می‌توان خروجی فیلتر کالمن را بر روی مدل خطی در هر لحظه به ازای یک پنجره خاص زمانی مشاهده کرد.

\begin{figure}
\includegraphics[width=1\textwidth]{Returns and Kalman Filtering [Linear Model without Control].png}
\centering
\end{figure}
\end{نتیجه}

\subsubsection{مدل ۲: دینامیک خطی همراه با کنترل}
در مدل زیر، فرض می‌کنیم تعدادی ویژگی (که در بخش قبل تهیه شده‌اند و در همان بخش، همبستگیشان با تابع هدف ما بررسی و تایید شده است) نیز علاوه بر بردار
$\bold{x^{(n-1)}}$،
در دینامیک تغییرات قیمت به شکل خطی موثر باشند. به عبارت دیگر دینامیک مساله را با مدل زیر تقریب می‌زنیم:

\begin{equation}\label{linear_model_with_control}
\tilde{r}_n = f_{0, n}\tilde{r}_{n-1} + \sum_{i=1}^{m-1}f_{i, n} r_{i,n-1} + f_{m, n} + \sum_{i=0}^{s-1}g_{i,n}u_{i,n} + w_n,
\qquad
w_n \sim \mathcal{N}(0,\ \sigma_n^{2}) \..
\end{equation}

که با فرم زیر معادل است:

\begin{equation}
\bold{x^{(n)}} = F_n\bold{x^{(n-1)}} + G_n\bold{u^{(n)}} + \bold{w^{(n)}},
\end{equation}

و در آن
$\bold{u^{(n)}}$
بردار ویژگی‌ها در لحظه
$n$
است. در واقع:

\begin{center}
$
G_n := 
\begin{bmatrix}
g_{0, n} & \dots & g_{s-1, n} \\
0 & \dots & 0 \\
 & \ddots & \\
0 & \dots & 0
\end{bmatrix},
\quad 
\bold{u^{(n)}} := 
\begin{bmatrix}
u_{0, n} \\
\vdots \\
u_{s-1, n}
\end{bmatrix}\..
$
\end{center}

با در نظر گرفتن ماتریس
$X^{(n)}$
و بردار
$\bold{b^{(n)}_0}$
مدل قبلی، و تعریف ماتریس
$U_{n}$
و بردار
$\theta'_n$
به شکل زیر،

\begin{center}
$
U_{n} := 
\begin{bmatrix}
\bold{u^{(n - (k-1))}}^T \\
\vdots \\
\bold{u^{(n)}}^T \\
\end{bmatrix},
\qquad
\theta'_n :=
\begin{bmatrix}
g_{0,n} \\
\vdots \\
g_{s-1,n}
\end{bmatrix}
$
\end{center}

می‌توان به سادگی و مشابه با روند مدل
\ref{linear_model_without_control}،
به مساله کمترین مجموع مربعات زیر دست یافت:

\begin{equation}\label{linear_model_with_control_optimization}
for\ given\ n:\quad minimize_{(\theta_n, \theta'_n)}\ ||X^{(n-1)}\theta_n + U_{n}\theta'_n - \bold{b^{(n)}_0}||_2^2
\end{equation}

اکنون با ادغام دو ماتریس
$X^{(n-1)}$
و
$U_n$
و ادغام دو بردار
$\theta_n$
و
$\theta'_n$
مساله بهینه‌سازی معادل زیر را داریم:

\begin{center}
$
A_n := 
\begin{bmatrix}
X^{(n-1)} & U_n
\end{bmatrix},
\quad
\theta^*_n :=
\begin{bmatrix}
\theta_n \\
\theta'_n
\end{bmatrix}
\qquad
\longrightarrow
\qquad
for\ given\ n:\quad minimize_{(\theta^*_n)}\ ||A_n\theta^*_n - \bold{b^{(n)}_0}||_2^2
$
\end{center}


در ادامه به بررسی نتایج حاصل از حل مساله بهینه‌سازی
\ref{linear_model_with_control_optimization}
به کمک روش کمترین مجموع مربعات و پیاده‌سازی فیلتر کالمن بر روی مدل
\ref{linear_model_with_control}
می‌پردازیم.

\begin{مشاهده}
مطابق با نمودار زیر می‌توان فرض نرمال بودن نویز در اندازه‌گیری و مدل را مجددا تا حدودی تایید کرد. هرچند همانطور که از نمودار پیداست، واریانس مدل کمی افزایش (جزیی) داشته و کم نشده است! در بخش‌های بعدی، زمانی که همه مدل‌های خطی را معرفی کردیم و به مقایسه عملکرد آن‌ها پرداختیم، دلیل عملیاتی این موضوع را توضیح خواهیم داد.

\begin{figure}
\includegraphics[width=0.5\textwidth]{Errors Histogram [Linear Model with Control].png}
\centering
\end{figure}
\end{مشاهده}


\begin{مشاهده}
نمودار زیر مشابه با نمودار مربوط به مدل
\ref{linear_model_without_control}
قابل قبول است. نکته حایز اهمیت در این نمودار، تباهیده شدن ضرایب مربوط به ویژگی‌هاست که در واقع به دلیل انحراف معیار بالاتر ستون‌های مربوط به ویژگی‌ها نسبت به ستون‌های مربوط به بازدهی است و اطلاعاتی از دست نرفته است.

\begin{figure}
\includegraphics[width=1.1\textwidth]{Heatmap [Linear Model with Control].png}
\centering
\end{figure}
\end{مشاهده}

\begin{نتیجه}
در شکل
\ref{kalman_1}
 می‌توان خروجی فیلتر کالمن را بر روی مدل خطی در هر لحظه به ازای یک پنجره خاص زمانی مشاهده کرد.

\begin{figure}\label{kalman_1}
\includegraphics[width=1\textwidth]{Returns and Kalman Filtering [Linear Model with Control].png}
\centering
\end{figure}
\end{نتیجه}




\subsubsection{مدل ۳: دینامیک خطی حساس به زمان}
منظور از مدل حساس به زمان، مدلی است که به نوعی به  اطلاعات اخیرتر بیشتر توجه دارد (مثلا توسط یک ماتریس وزن‌دهی). همانطور که می‌توان حدس زد، چنین مدلی اساسا واریانس نویز بیشتری دارد. اما در عوض ممکن است به کمک فیلتر کالمن بتوان نویز آن را بهتر کنترل کرد، چرا که چنین مدلی در صورت خطی بودن واقعیت دینامیک مساله، سریع‌تر بروزرسانی می‌شود.

به دو روش می‌توان حساسیت به زمان را در مدل منعکس کرد. یکی حساسیت در یادگیری پارامترها، و دیگری حساسیت در توجه به اطلاعات سری زمانی.

روش اول معادل است با مساله بهینه‌سازی زیر:

\begin{equation}\label{first_weighted_linear_model_with_control_optimization}
for\ given\ n:\quad minimize_{(\theta^*_n)}\ ||D_1A_n\theta^*_n - D_1\bold{b^{(n)}_0}||_2^2,
\quad
D_1 = \dfrac{1}{\lambda}diag(\alpha^0,\ \dots, \ \alpha^{k-1}),\ \lambda= \sum_{i=0}^{k-1} \alpha^i
\end{equation}
که در آن
$\alpha$
پارامتر تاثیرگذاری است و مقداری حداقل برابر با
$1$
دارد. پارامتر
$\alpha$
در واقع بیان می‌کند کوچک کردن هر مقدار باقیمانده
$w_j$
در مساله مجموع کمترین مربعات، چه اندازه از کوچک کردن مقدار باقیمانده
$w_{j-1}$
مهم‌تر است.

روش دوم معادل است با وزن‌دهی به درایه‌های بردار
$\theta_n$
به گونه‌ای که هرچه اندیس
$i$
در
$f_{i, n}$
افزایش می‌یابد،
$|f_{i,n}|$
کاهش یابد. پس باید وزن‌های بزرگ‌تری به
$f_{i,n}$های
با اندیس بزرگ‌تر در مساله بهینه‌سازی
\ref{linear_model_with_control_optimization}
بدهیم. یعنی مساله بهینه‌سازی زیر:

\label{second_weighted_linear_model_with_control_optimization}
\begin{equation}
for\ given\ n:\quad minimize_{(\theta^*_n)}\ |
\begin{bmatrix}
X^{(n-1)}D_2 & U_n
\end{bmatrix}
\theta^*_n - \bold{b^{(n)}_0}||_2^2,
\quad
D_2 = \dfrac{1}{\lambda}diag(\alpha^0,\ \dots, \ \alpha^{m}),\ \lambda= \sum_{i=0}^{m} \alpha^i
\end{equation}

در ادامه تنها نتیجه حل مساله بهینه‌سازی
\ref{first_weighted_linear_model_with_control_optimization}
آمده‌ است:

\begin{مشاهده}
ابتدا به ازای مقادیر مختلف
$\alpha$
با بررسی دقت پیش‌بینی (صرفا درستی علامت
$\tilde{r}_n$)
و انحراف معیار نویز مدل، بهترین
$\alpha$
را انتخاب می‌کنیم:

\begin{figure}
\includegraphics[width=3in]{alpha comparison.png}
\centering
\end{figure}

بر اساس شکل در می‌یابیم نقاطی که در پیش‌بینی جهت
$\tilde{r}_n$
بیشترین دقت را دارند (از تشخیص تصادفی فاصله دارند و در عین حال انحراف معیار نویزشان کم است) عبارت‌اند از
$0.94$
و
$1$.
از طرفی کمترین انحراف معیار نویز، همانطور که پیش بینی شده بود، در حوالی 
$1$
رخ می‌دهد. پس اگر به دنبال مقداری غیر بدیهی (مخالف
$1$)
هستیم،
$\alpha=0.94$
گزینه مناسبی است. (توجه می‌کنیم که نیمه عمر چنین انتخابی حدود ۱۲ است، یعنی حساسیت مدل به داده هر لحظه حدود دو برابر حساسیت آن به داده ۱۲ کندل قبل است!)

هم‌چنین در ادامه تصویری از هیستوگرام نویز تعدادی از انتخاب‌های
$\alpha$
قابل مشاهده است.

\begin{figure}
\subfloat[$\alpha^{-1} = 0.93$]{\includegraphics[width = 2in]{Errors Histogram [Weighted (93\%) Linear Model with Control].png}} 
\subfloat[$\alpha^{-1} = 0.94$]{\includegraphics[width = 2in]{Errors Histogram [Weighted (94\%) Linear Model with Control].png}} 
\subfloat[$\alpha^{-1} = 0.95$]{\includegraphics[width = 2in]{Errors Histogram [Weighted (95\%) Linear Model with Control].png}} \\
\subfloat[$\alpha^{-1} = 0.96$]{\includegraphics[width = 2in]{Errors Histogram [Weighted (96\%) Linear Model with Control].png}} 
\subfloat[$\alpha^{-1} = 0.97$]{\includegraphics[width = 2in]{Errors Histogram [Weighted (97\%) Linear Model with Control].png}} 
\subfloat[$\alpha^{-1} = 0.98$]{\includegraphics[width = 2in]{Errors Histogram [Weighted (98\%) Linear Model with Control].png}} 
\label{alpha_values}
\centering
\end{figure}
\end{مشاهده}

\begin{نتیجه}
در شکل
\ref{kalman_2}
 می‌توان خروجی فیلتر کالمن را بر روی مدل خطی حساس به زمان ( با
$\alpha^{-1} = 0.94$)
در هر لحظه به ازای یک پنجره خاص زمانی مشاهده کرد.

\begin{figure}[H]\label{kalman_2}
\includegraphics[width=1\textwidth]{Returns and Kalman Filtering [Weighted (94\%) Linear Model with Control]}
\centering
\end{figure}
\end{نتیجه}





\subsubsection{مدل ۴: دینامیک خطی با ماتریس چگال}
در مدل‌های قبل، برای سهولت در محاسبه و سادگی مدل، فرض کردیم ماتریس‌های
$F_n$
و
$G_n$
تنک هستند. در این مدل، بدون تغییر فرض خطی بودن دینامیک مساله، فرض تنک بودن
$F_n$
و
$G_n$
را حذف می‌کنیم. در این صورت هرچند واریانس نویز تقریب آخرین بازدهی افزایش می‌یابد، اما با توجه به اینکه حالت تنک معادله خطی زیر، یک حالت خاص از معادله کلی است، انتظار داریم مساله بهینه‌سازی بتواند جواب‌های پایدارتری تولید کند. فایده دستگاه‌های خطی با واریانس نویز
$w_n$
بالاتر ولی پایداری بیشتر ان است که در بازارهای مالی به طور طبیعی مقدار بسیار زیادی نویز غیر قابل کنترل وجود دارد، و با پایدارتر کردن مدل، به ذات دینامیک مساله بهتر دسترسی داریم. (با فرض شبیه به خطی بودن این دینامیک)

\begin{center}
$
\bold{x^{(n)}} = F_n\bold{x^{(n-1)}} + G_n\bold{u^{(n)}} + \bold{w^{(n)}}
$
\end{center}

هم‌چنین در مدل بالا، فرض کنیم یک بردار آفست
$\bold{h^{(n)}}$
نیز در هر لحظه به سمت راست معادله اضافه می‌شود و در عوض
$\bold{w^{(n)}}$
توزیع نرمال با میانگین
$\bold{0}$
دارد. در این صورت مساله بهینه‌سازی یافتن بهترین پارامترها برای تقریب خطی دینامیک مساله، در فرم کلی خود به صورت زیر است:

\begin{equation}
for\ given\ n:\qquad minimize_{(F_n,\ G_n,\ \bold{h^{(n)}})}\quad \big| \big|
\begin{bmatrix}
F_n & G_n & diag(\bold{h^{(n)}})
\end{bmatrix}
\begin{bmatrix}
\bold{x^{(n-1)}} \\
\bold{u^{(n)}} \\
\bold{1_{m\times 1}}
\end{bmatrix}
- \bold{x^{(n)}}\big|\big|_{2}^{2}
\end{equation}

که با ترانهاده گرفتن از دو عبارت ماتریسی، و تکرار آنچه در مورد مدل
\ref{linear_model_without_control}
بیان شد، به فرم زیر رسید:

\begin{equation}\label{dense_linear_model}
for\ given\ n:\qquad minimize_{(F_n,\ G_n,\ \bold{h^{(n)}})}\quad \big| \big|
\begin{bmatrix}
X^{(n-1)} & U_n & \bold{1_{k\times m}}
\end{bmatrix}
\begin{bmatrix}
F_n^{T}\\
G_n^{T}\\
diag(\bold{h^{(n)}})
\end{bmatrix}
- X^{(n)}
\big|\big|_{2}^{2}
\end{equation}

مساله بهینه‌سازی فوق که تعمیم کمترین مجموع مربعات عادی به ماتریس مجهول است، در تمرین
$13\..15$
کتاب
\cite{vmls}
بررسی شده است. در واقع هر ستون ماتریس مجهول به شکل جداگانه با روش کمترین مجموع مربعات یافته می‌شود و سپس کل ماتریس را از کنار هم قرار دادن این ستون‌ها معرفی می‌کنیم
\cite{numpy}.
 توجه می‌کنیم که پس از یافتن ماتریس مجهول، در واقع ستون اول به تنهایی برای تشکیل دینامیک خطی همراه با کنترل لازم است. اما کل ماتریس را برای محاسبه ماتریس‌های کواریانس در هر مرحله از الگوریتم کالمن ذخیره می‌کنیم.






% --------------------------------------------- %
\section{فیلتر کالمن تعمیم‌یافته}
% --------------------------------------------- %
در صورتی که دینامیک مساله غیرخطی باشد، فیلتر کالمن دیگر تضمینی برای بهترین جواب بودن ندارد. اما هم‌چنان می‌توان با خطی‌سازی از تقریب کالمن استفاده کرد
\cite{intech}.
 فرض کنیم دینامیک مساله به شکل زیر تقریب زده شود:

\begin{equation}\label{nonlinear_dynamics}
\begin{cases}
\bold{x_k} = f(\bold{x_{k-1}}, \bold{u_k}) + \bold{w_k}\\
\bold{z_k} = h({\bold{x_{k-1}}}) + \bold{v_k}
\end{cases}
\end{equation}

در این صورت می‌توان در فرمول‌های فیلتر کالمن، به جای
$F$
و
$H$،
تقریب خطی توابع
$f$
و
$h$
را گذاشت. در نتیجه الگوریتم شکل 
\ref{extendedalgo}
 را خواهیم داشت
\cite{intech}:


\begin{figure}\label{extendedalgo}
\includegraphics[width=6in]{algorithm2.png}
\centering
\end{figure}

که در آن

\begin{equation}
\begin{cases}
F_{k-1} = \dfrac{\partial f}{\partial x} |_{\bold{\hat{x}^+_{k-1}}, \bold{u_{k-1}}}\\
H_{k} = \dfrac{\partial h}{\partial x}|_{\bold{\hat{x}^-_{k}}}
\end{cases}
\end{equation}


\section{فیلتر کالمن با چند مدل}
 یک چالش پیش رو این است که احتمالا هیچ یک از برآوردگرهای قبلی یک غلبه کامل در همه حالات نسبت به سایرین ندارد و هر کدام تحت شرایط خاصی بهتر از بقیه عمل می‌کند. در صورتی که در الگوریتم کالمن فقط یک برآوردگر داریم.
حال ما می‌خواهیم الگوریتم کالمن را به نحوی توسعه دهیم که در حالت وجود چندین برآوردگر اولیه نیز کارآمد باشد. اساس این روش به این صورت خواهد بود که میانگین وزن‌داری از برآوردگرها و دستگاه‌های اندازه‌گیری (برآوردگر یا ابزار اندازه‌گیری  
$i$ام 
را با
$\hat{x}_i$
 نمایش می‌دهیم) را به عنوان برآورد نهایی خود قرار دهیم و نحوه وزن‌دهی به برآوردگرها نسبت معکوس با عدم قطعیت موجود (واریانس) در آن برآوردگر داشته باشد. شکل زیر برگرفته از مدل ارایه شده در
 \cite{multimodels2}
 است.
 

\begin{figure}[H]\label{multimodel}
\includegraphics[width=.6\textwidth]{multimodel1.jpg}
\centering
\end{figure}
 
 
به طرق مختلف میتوان این کار را انجام داد
\cite{multimodels}. به عنوان مثال ابتدا هر مدل را با مشاهدات خود فیلتر کنیم و بعد میانگین وزن داری از آنها را بگیریم. یا ابتدا میانگین وزن‌داری از برآوردگرها را محاسبه کنیم و مقدار آن را به عنوان تقریب خام اولیه به الگوریتم کالمن بدهیم. یک راه دیگر اینست که برآوردگر
$i$ام 
را با برآوردگر 
$i+1$ام
به طور سری تلفیق کنیم (در این جا برآوردگر 
$i+1$ام
 نقش دستگاه اندازه گیری را بازی می‌کند) و نتیجه را با برآوردگر
 $i+2$ام
  تلفیق کنیم و همین‌طور الی آخر.




\section{خلاصه}
در این گزارش، الگوریتم کالمن را به همراه پیاده‌سازی‌اش روی داده‌های قیمتی بیت‌کوین ارایه کردیم. شکل زیر به طور خلاصه متغیرها و الگوریتم را توضیح می‌دهد:

\begin{figure}[H]\label{summary}
\includegraphics[width=.8\textwidth]{summary.png}
\centering
\end{figure}




\section{ادامه}

به طرق مختلفی می‌توان این مساله را تعمیم داد. در زیر به راهکارهایی برای تعمیم به حالت کلی‌تر سوال می‌پردازیم.

\begin{itemize}
\item{
چهار ویژگی ذکر شده بنا به تجربه قابل مطالعه‌تر از شاخص‌های مرسوم بازار بودند. می‌توان تعداد زیادی شاخص تصادفی تولید کرد و با استخراج ویژگی‌های جدید مناسب از آن‌ها برای استفاده در سری زمانی بهره گرفت.
}
\item{
مقدار حافظه سری زمانی و مقدار داده‌ای که برای محاسبه پارامترهای دینامیک سری‌های زمانی استفاده کردیم به طور دستی در این گزارش تنظیم شده بود. می‌توان روش‌هایی برای تنظیم خودکار آن‌ها بوجود آورد.
}
\item{
الگوریتم‌های بکار رفته در کدها دارای انواع پتانسیل‌ها برای بهبود بخشیدن چه از نظر سرعت اجرا چه از نظر دقت و غیره می‌باشند.
}
\end{itemize}



\bibliographystyle{alpha-persian}


\bibliography{main}


\end{document}